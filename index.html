<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>F-Shutter Heart Camera</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    body { 
      margin: 0; 
      overflow: hidden; 
      background: #000; 
      color: white; 
      font-family: monospace, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    #canvas { 
      touch-action: none; 
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    #ui { 
      position: absolute; 
      top: 15px; 
      left: 15px; 
      z-index: 10; 
      background: rgba(0,0,0,0.5);
      padding: 10px;
      border-radius: 8px;
    }
    .ui-item { font-size: 18px; color: white; margin-bottom: 5px; }
    #bpm { color: #ff4757; font-weight: bold; }
    #instructions {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      background: rgba(0,0,0,0.7);
      padding: 15px;
      border-radius: 10px;
      z-index: 20;
      pointer-events: none;
    }
    .button-container {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 15px;
      z-index: 10;
    }
    .button-container button {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      border: 4px solid white;
      background: rgba(255, 255, 255, 0.3);
      font-size: 28px;
      cursor: pointer;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    #capture-btn {
      background: #ff4757;
    }
    #gallery {
      position: absolute;
      bottom: 100px;
      left: 0;
      width: 100%;
      height: 90px;
      background: rgba(0,0,0,0.4);
      padding: 5px;
      box-sizing: border-box;
      display: flex;
      align-items: center;
      gap: 8px;
      overflow-x: auto;
      overflow-y: hidden;
      z-index: 10;
    }
    #gallery a {
      height: 100%;
      display: inline-block;
    }
    #gallery img {
      height: 100%;
      border-radius: 5px;
      border: 2px solid white;
      cursor: pointer;
      transition: transform 0.1s ease;
    }
    #gallery img:hover {
      transform: scale(1.05);
    }
    #graph {
      position: absolute;
      top: 0;
      right: 0;
      width: 200px;
      height: 100px;
      background: rgba(0, 0, 0, 0.5);
      z-index: 20;
    }
  </style>
</head>
<body>
  <div id="ui">
    <div id="bpm" class="ui-item">BPM: ---</div>
    <div id="fval-display" class="ui-item">FÂÄ§: 4.0</div>
  </div>
  <div id="instructions">
    <p>ËÉåÈù¢„ÅÆ„Ç´„É°„É©„Å®„É©„Ç§„Éà„Çí<br>Êåá„Åß„Åù„Å£„Å®Ë¶Ü„Å£„Å¶„Åè„Å†„Åï„ÅÑ</p>
    <p>‚Üì</p>
    <p>‰∏ã„ÅÆ„É©„Ç§„Éà„Éú„Çø„É≥(üí°)„ÇíÊäº„Åó„Å¶<br>Ë®àÊ∏¨„ÇíÈñãÂßã„Åó„Åæ„Åô</p>
  </div>
  <canvas id="canvas"></canvas>
  <canvas id="graph"></canvas>
  <div id="gallery"></div>
  <div class="button-container">
    <button id="flash-btn">üí°</button>
    <button id="capture-btn">üì∏</button>
  </div>
<script>
let video, canvas, ctx, graphCanvas, graphCtx;
let videoTrack;
let fValue = 4.0;
let bpm = 0;
let redHistory = [];
let lastPinchDist = 0;
let isFlashOn = false;
let isMeasuring = false;
let scale = 1.0;

const bpmText = document.getElementById("bpm");
const fvalText = document.getElementById("fval-display");
const instructions = document.getElementById("instructions");
const flashBtn = document.getElementById("flash-btn");
const captureBtn = document.getElementById("capture-btn");

async function initCamera() {
  video = document.createElement("video");
  video.setAttribute("autoplay", true);
  video.setAttribute("playsinline", true);

  try {
    const stream = await navigator.mediaDevices.getUserMedia({ 
      video: { 
        facingMode: "environment",
        width: { ideal: 1280 },
        height: { ideal: 720 }
      } 
    });
    video.srcObject = stream;
    const tracks = stream.getVideoTracks();
    if (tracks.length > 0) videoTrack = tracks[0];
  } catch (err) {
    alert("„Ç´„É°„É©„ÅÆËµ∑Âãï„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ\n" + err);
    return;
  }

  video.addEventListener("loadeddata", () => {
    setupCanvas();
    requestAnimationFrame(draw);
  });
}

function setupCanvas() {
  canvas = document.getElementById("canvas");
  ctx = canvas.getContext("2d");
  graphCanvas = document.getElementById("graph");
  graphCtx = graphCanvas.getContext("2d");

  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  graphCanvas.width = 200;
  graphCanvas.height = 100;

  canvas.addEventListener("wheel", e => {
    e.preventDefault();
    scale += e.deltaY * -0.001;
    updateFValue();
  }, { passive: false });

  canvas.addEventListener("touchstart", e => { if (e.touches.length === 2) lastPinchDist = dist(e.touches[0], e.touches[1]); });
  canvas.addEventListener("touchmove", e => {
    e.preventDefault();
    if (e.touches.length === 2) {
      const currentDist = dist(e.touches[0], e.touches[1]);
      scale += (currentDist - lastPinchDist) * 0.005;
      lastPinchDist = currentDist;
      updateFValue();
    }
  }, { passive: false });
}

function updateFValue() {
  scale = Math.max(0.25, Math.min(scale, 4.0));
  fValue = 16.0 / scale / 4.0;
  fvalText.innerText = `FÂÄ§: ${fValue.toFixed(1)}`;
}

function dist(p1, p2) {
  return Math.hypot(p1.clientX - p2.clientX, p1.clientY - p2.clientY);
}

function draw() {
  const videoRatio = video.videoWidth / video.videoHeight;
  const canvasRatio = canvas.width / canvas.height;
  let drawWidth, drawHeight, startX, startY;
  if (videoRatio > canvasRatio) {
    drawHeight = canvas.height; drawWidth = drawHeight * videoRatio;
    startX = (canvas.width - drawWidth) / 2; startY = 0;
  } else {
    drawWidth = canvas.width; drawHeight = drawWidth / videoRatio;
    startY = (canvas.height - drawHeight) / 2; startX = 0;
  }

  ctx.drawImage(video, startX, startY, drawWidth, drawHeight);

  if (isMeasuring) {
    const frame = ctx.getImageData(canvas.width / 2 - 50, canvas.height / 2 - 50, 100, 100);
    let sumRed = 0;
    for (let i = 0; i < frame.data.length; i += 4) {
      sumRed += frame.data[i];
    }
    const avgRed = sumRed / (frame.data.length / 4);
    if (!isNaN(avgRed)) {
      redHistory.push({ value: avgRed, time: Date.now() });
    }
    drawGraph();
  }

  ctx.fillStyle = "rgba(0,0,0,0.8)";
  ctx.beginPath();
  const outerRadius = Math.max(canvas.width, canvas.height);
  ctx.arc(canvas.width / 2, canvas.height / 2, outerRadius, 0, 2 * Math.PI);
  const innerRadius = 50 * scale;
  ctx.arc(canvas.width / 2, canvas.height / 2, innerRadius, 0, 2 * Math.PI, true);
  ctx.fill();

  requestAnimationFrame(draw);
}

function drawGraph() {
  const values = redHistory.slice(-200).map(p => p.value);
  const max = Math.max(...values);
  const min = Math.min(...values);

  graphCtx.clearRect(0, 0, graphCanvas.width, graphCanvas.height);
  graphCtx.beginPath();
  values.forEach((v, i) => {
    const x = (i / values.length) * graphCanvas.width;
    const y = graphCanvas.height - ((v - min) / (max - min + 1e-6)) * graphCanvas.height;
    if (i === 0) graphCtx.moveTo(x, y);
    else graphCtx.lineTo(x, y);
  });
  graphCtx.strokeStyle = "#00ff88";
  graphCtx.lineWidth = 1.5;
  graphCtx.stroke();
}

function calculateBPM_FFT(history) {
  if (history.length < 64) return 0;

  const signal = history.map(p => p.value);
  const times = history.map(p => p.time);
  const duration = (times[times.length - 1] - times[0]) / 1000;

  const mean = signal.reduce((a, b) => a + b, 0) / signal.length;
  const centered = signal.map(v => v - mean);
  const stdDev = Math.sqrt(centered.map(v => v ** 2).reduce((a, b) => a + b) / centered.length);

  if (stdDev < 0.5) return 0; // ‰ø°Âè∑Âº±„Åô„Åé

  const n = signal.length;
  const re = new Array(n).fill(0), im = new Array(n).fill(0);

  for (let k = 0; k < n; k++) {
    for (let t = 0; t < n; t++) {
      const angle = (2 * Math.PI * t * k) / n;
      re[k] += centered[t] * Math.cos(angle);
      im[k] -= centered[t] * Math.sin(angle);
    }
  }

  const power = re.map((r, i) => Math.sqrt(r ** 2 + im[i] ** 2));
  const freqResolution = 1 / duration;
  const bpmList = power.map((p, i) => ({ bpm: (i * freqResolution) * 60, power: p }));

  const filtered = bpmList.filter(p => p.bpm >= 40 && p.bpm <= 200);
  if (filtered.length === 0) return 0;

  const peak = filtered.reduce((a, b) => a.power > b.power ? a : b);
  return Math.round(peak.bpm);
}

flashBtn.addEventListener("click", () => {
  if (!videoTrack || isMeasuring) return;

  isFlashOn = !isFlashOn;
  videoTrack.applyConstraints({ advanced: [{ torch: isFlashOn }] });
  flashBtn.style.background = isFlashOn ? "#ffdd59" : "rgba(255, 255, 255, 0.3)";

  if (isFlashOn) {
    instructions.style.display = 'none';
    isMeasuring = true;
    redHistory = [];
    bpmText.innerText = 'BPM: Ë®àÊ∏¨‰∏≠...';
    flashBtn.disabled = true;

    setTimeout(() => {
      isMeasuring = false;
      flashBtn.disabled = false;
      const result = calculateBPM_FFT(redHistory);
      if (result < 40 || result > 200 || isNaN(result)) {
        bpmText.innerText = "BPM: Ê∏¨ÂÆöÂ§±Êïó";
        bpm = 0;
      } else {
        bpm = result;
        bpmText.innerText = `BPM: ${bpm}`;
      }
    }, 8000);
  } else {
    bpmText.innerText = 'BPM: ---';
    isMeasuring = false;
  }
});

captureBtn.addEventListener("click", () => {
  const tempCanvas = document.createElement('canvas');
  const tempCtx = tempCanvas.getContext('2d');
  tempCanvas.width = canvas.width; 
  tempCanvas.height = canvas.height;
  tempCtx.drawImage(canvas, 0, 0);

  const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
  const data = imageData.data;

  const currentBpm = (bpm > 40 && bpm < 200) ? bpm : 75;
  const factor = 2.0 / (fValue * (currentBpm / 60));

  for (let i = 0; i < data.length; i += 4) {
    data[i] = Math.min(255, data[i] * factor);
    data[i+1] = Math.min(255, data[i+1] * factor);
    data[i+2] = Math.min(255, data[i+2] * factor);
  }
  tempCtx.putImageData(imageData, 0, 0);

  const dataURL = tempCanvas.toDataURL("image/jpeg", 0.9);
  const gallery = document.getElementById('gallery');
  const link = document.createElement('a');
  link.href = dataURL;
  link.download = `heart_camera_f${fValue.toFixed(1)}_bpm${currentBpm}.jpg`;

  const thumbImg = document.createElement('img');
  thumbImg.src = dataURL;
  link.appendChild(thumbImg);
  gallery.appendChild(link);
  gallery.scrollLeft = gallery.scrollWidth;
});

initCamera();
</script>
</body>
</html>
