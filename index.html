<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<title>F-Shutter Heart Camera</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no" />
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #000;
    color: #fff;
    font-family: monospace;
  }
  video,
  canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
  }
  #graph {
    position: absolute;
    top: 0;
    right: 0;
    width: 200px;
    height: 100px;
    background: rgba(0, 0, 0, 0.5);
    z-index: 10;
  }
  #ui {
    position: absolute;
    top: 15px;
    left: 15px;
    background: rgba(0, 0, 0, 0.5);
    padding: 10px 15px;
    border-radius: 8px;
    z-index: 10;
    user-select: none;
    font-size: 18px;
    line-height: 1.4;
    min-width: 110px;
  }
  #instructions {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.7);
    padding: 15px;
    border-radius: 10px;
    text-align: center;
    z-index: 10;
  }
  .button-container {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 15px;
    z-index: 10;
  }
  button {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    border: 4px solid white;
    background: rgba(255, 255, 255, 0.3);
    font-size: 28px;
    cursor: pointer;
    user-select: none;
  }
  #flash-btn {
    background: #ff4757;
  }
  #gallery {
    position: absolute;
    bottom: 100px;
    left: 0;
    width: 100%;
    height: 90px;
    background: rgba(0, 0, 0, 0.4);
    display: flex;
    align-items: center;
    overflow-x: auto;
    gap: 8px;
    box-sizing: border-box;
    z-index: 10;
  }
  #gallery img {
    height: 100%;
    border: 2px solid white;
    border-radius: 5px;
    cursor: pointer;
    transition: transform 0.1s;
  }
  #gallery img:hover {
    transform: scale(1.05);
  }
</style>
</head>
<body>
  <video id="video" playsinline autoplay muted></video>
  <canvas id="canvas"></canvas>
  <canvas id="graph"></canvas>

  <div id="ui">
    <div id="bpm">BPM: ---</div>
    <div id="fval">F値: 4.0</div>
  </div>

  <div id="instructions">
    <p>背面カメラとライトを指で覆ってください</p>
    <p>↓</p>
    <p>💡 を押して計測開始</p>
  </div>

  <div class="button-container">
    <button id="flash-btn">💡</button>
    <button id="capture-btn">📸</button>
  </div>

  <div id="gallery"></div>

<script>
(async () => {
  const video = document.getElementById("video");
  const canvas = document.getElementById("canvas");
  const graph = document.getElementById("graph");
  const bpmText = document.getElementById("bpm");
  const fvalText = document.getElementById("fval");
  const instr = document.getElementById("instructions");
  const flashBtn = document.getElementById("flash-btn");
  const capBtn = document.getElementById("capture-btn");
  const gallery = document.getElementById("gallery");

  const ctx = canvas.getContext("2d");
  const gctx = graph.getContext("2d");

  let videoTrack;
  let scale = 1;
  let fValue = 4;
  let bpm = 0;
  let avgBpm = 80; // 標準値を80に設定

  let measuring = false;
  let history = [];
  let lastPinch = 0;

  // カメラ起動
  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: "environment" }
    });
    video.srcObject = stream;
    videoTrack = stream.getVideoTracks()[0];
  } catch (err) {
    alert("カメラ起動失敗：" + err);
    return;
  }

  function resize() {
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    graph.width = 200;
    graph.height = 100;
  }
  video.addEventListener("loadeddata", () => {
    resize();
    requestAnimationFrame(loop);
  });
  window.addEventListener("resize", resize);

  function loop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.filter = "none";
    ctx.globalAlpha = 1;
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

    if (measuring) {
      const s = 100;
      const x = canvas.width / 2 - s / 2,
        y = canvas.height / 2 - s / 2;
      const dat = ctx.getImageData(x, y, s, s).data;
      let sum = 0;
      for (let i = 0; i < dat.length; i += 4) sum += dat[i];
      history.push({ v: sum / (dat.length / 4), t: Date.now() });
      drawGraph();
    }

    // 明るさ調整: BPMが80を基準、60以下で明るく、100以上で暗く
    let alphaBase = 1;
    if (bpm <= 60) {
      alphaBase = 1.3; // 明るく
    } else if (bpm >= 100) {
      alphaBase = 0.7; // 暗く
    }
    ctx.globalAlpha = (4 / fValue) * alphaBase;

    requestAnimationFrame(loop);
  }

  function drawGraph() {
    const arr = history.slice(-200).map((o) => o.v);
    const min = Math.min(...arr),
      max = Math.max(...arr);
    gctx.clearRect(0, 0, 200, 100);
    gctx.beginPath();
    arr.forEach((v, i) => {
      const x = (i / arr.length) * 200;
      const y = 100 - ((v - min) / (max - min + 1e-6)) * 100;
      i === 0 ? gctx.moveTo(x, y) : gctx.lineTo(x, y);
    });
    gctx.strokeStyle = "#0f8";
    gctx.lineWidth = 1.5;
    gctx.stroke();
  }

  // BPM計算（FFTの簡易版）
  function calcBPM() {
    const h = history;
    if (h.length < 60) return 0;
    const vals = h.map((o) => o.v),
      times = h.map((o) => o.t);
    const dur = (times[times.length - 1] - times[0]) / 1000;
    if (dur < 5) return 0;
    const mean = vals.reduce((a, b) => a + b) / vals.length;
    const cen = vals.map((v) => v - mean);
    const std = Math.sqrt(
      cen.map((v) => v * v).reduce((a, b) => a + b) / cen.length
    );
    if (std < 0.5) return 0;

    const n = cen.length;
    const re = new Array(n).fill(0),
      im = new Array(n).fill(0);
    for (let k = 0; k < n; k++)
      for (let t = 0; t < n; t++) {
        const ang = (2 * Math.PI * t * k) / n;
        re[k] += cen[t] * Math.cos(ang);
        im[k] -= cen[t] * Math.sin(ang);
      }
    const power = re.map((r, i) => Math.hypot(r, im[i]));
    const freqRes = 1 / dur;
    const peaks = power
      .map((p, i) => ({ bpm: i * freqRes * 60, power: p }))
      .filter((o) => o.bpm >= 40 && o.bpm <= 200);
    if (!peaks.length) return 0;
    const peak = peaks.reduce((a, b) => (a.power > b.power ? a : b));
    return Math.round(peak.bpm);
  }

  flashBtn.onclick = async () => {
    if (!videoTrack || measuring) return;
    measuring = true;
    history = [];
    instr.style.display = "none";
    bpmText.innerText = "BPM: 計測中...";
    try {
      await videoTrack.applyConstraints({ advanced: [{ torch: true }] });
    } catch (e) {
      console.warn("Torch failed", e);
    }
    setTimeout(async () => {
      measuring = false;
      try {
        await videoTrack.applyConstraints({ advanced: [{ torch: false }] });
      } catch (e) {}
      const r = calcBPM();
      if (r < 40 || r > 200) {
        bpmText.innerText = "BPM: 測定失敗";
        bpm = avgBpm;
      } else {
        bpm = r;
        avgBpm = bpm;
        bpmText.innerText = `BPM: ${bpm}`;
      }
    }, 8000);
  };

  capBtn.onclick = () => {
    // 撮影用キャンバス生成
    const tmp = document.createElement("canvas");
    tmp.width = canvas.width;
    tmp.height = canvas.height;
    const tc = tmp.getContext("2d");

    // 写真にかける明暗フィルターの適用
    tc.filter = computeFilterForBPM(bpm, fValue);
    tc.drawImage(canvas, 0, 0);

    const url = tmp.toDataURL("image/jpeg", 0.9);
    const a = document.createElement("a"),
      img = document.createElement("img");
    a.href = url;
    a.download = `f${fValue.toFixed(1)}_bpm${bpm || avgBpm}.jpg`;
    img.src = url;
    a.appendChild(img);
    gallery.appendChild(a);
    gallery.scrollLeft = gallery.scrollWidth;
  };

  // BPMに応じた明暗フィルターを返す（CSS filter形式）
  function computeFilterForBPM(bpmValue, fval) {
    // 基準80
    let brightness = 1;
    if (bpmValue <= 60) brightness = 1.3;
    else if (bpmValue >= 100) brightness = 0.7;

    // F値に応じて少しぼかしを加える（fval大きい＝絞る＝ピント深くなる＝ぼかし弱い）
    // ここは適当に調整可能
    let blurPx = (4 - fval) * 2;
    if (blurPx < 0) blurPx = 0;
    if (blurPx > 6) blurPx = 6;

    return `brightness(${brightness}) blur(${blurPx}px)`;
  }

  // ホイールでF値調整
  canvas.onwheel = (e) => {
    e.preventDefault();
    scale += -e.deltaY * 0.001;
    scale = Math.max(0.25, Math.min(scale, 4));
    fValue = 16 / scale / 4;
    fvalText.innerText = `F値: ${fValue.toFixed(1)}`;
  };

  // ピンチ操作でF値調整
  canvas.addEventListener("touchstart", (e) => {
    if (e.touches.length === 2)
      lastPinch = Math.hypot(
        e.touches[0].clientX - e.touches[1].clientX,
        e.touches[0].clientY - e.touches[1].clientY
      );
  });
  canvas.addEventListener("touchmove", (e) => {
    if (e.touches.length === 2) {
      const d = Math.hypot(
        e.touches[0].clientX - e.touches[1].clientX,
        e.touches[0].clientY - e.touches[1].clientY
      );
      scale += (d - lastPinch) * 0.005;
      lastPinch = d;
      scale = Math.max(0.25, Math.min(scale, 4));
      fValue = 16 / scale / 4;
      fvalText.innerText = `F値: ${fValue.toFixed(1)}`;
    }
  });
})();
</script>
</body>
</html>
