<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>F-Shutter Heart Camera</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    body { 
      margin: 0; 
      overflow: hidden; 
      background: #000; 
      color: white; 
      font-family: monospace, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    #canvas { 
      touch-action: none; 
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    #ui { 
      position: absolute; 
      top: 15px; 
      left: 15px; 
      z-index: 10; 
      background: rgba(0,0,0,0.5);
      padding: 10px;
      border-radius: 8px;
    }
    .ui-item { font-size: 18px; color: white; margin-bottom: 5px; }
    #bpm { color: #ff4757; font-weight: bold; }
    #instructions {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      background: rgba(0,0,0,0.7);
      padding: 15px;
      border-radius: 10px;
      z-index: 20;
      pointer-events: none;
    }
    .button-container {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 15px;
      z-index: 10;
    }
    .button-container button {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      border: 4px solid white;
      background: rgba(255, 255, 255, 0.3);
      font-size: 28px;
      cursor: pointer;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    #capture-btn {
      background: #ff4757;
    }
  </style>
</head>
<body>

<div id="ui">
  <div id="bpm" class="ui-item">BPM: ---</div>
  <div id="fval-display" class="ui-item">Få€¤: 4.0</div>
</div>

<div id="instructions">
  <p>èƒŒé¢ã®ã‚«ãƒ¡ãƒ©ã¨ãƒ©ã‚¤ãƒˆã‚’<br>æŒ‡ã§ãã£ã¨è¦†ã£ã¦ãã ã•ã„</p>
  <p>â†“</p>
  <p>ä¸‹ã®ãƒ©ã‚¤ãƒˆãƒœã‚¿ãƒ³(ğŸ’¡)ã‚’æŠ¼ã—ã¦<br>è¨ˆæ¸¬ã‚’é–‹å§‹ã—ã¾ã™</p>
</div>

<canvas id="canvas"></canvas>

<div class="button-container">
  <button id="flash-btn">ğŸ’¡</button>
  <button id="capture-btn">ğŸ“¸</button>
</div>

<script>
let video, canvas, ctx;
let videoTrack;
let fValue = 4.0;
let bpm = 0;
let redHistory = []; // åå‰ã‚’å¤‰æ›´
let lastPinchDist = 0;
let isFlashOn = false;
let scale = 1.0;

const bpmText = document.getElementById("bpm");
const fvalText = document.getElementById("fval-display");
const instructions = document.getElementById("instructions");
const flashBtn = document.getElementById("flash-btn");
const captureBtn = document.getElementById("capture-btn");

async function initCamera() {
  video = document.createElement("video");
  video.setAttribute("autoplay", true);
  video.setAttribute("playsinline", true);

  try {
    const stream = await navigator.mediaDevices.getUserMedia({ 
      video: { 
        facingMode: "environment",
        width: { ideal: 1280 },
        height: { ideal: 720 }
      } 
    });
    video.srcObject = stream;
    const tracks = stream.getVideoTracks();
    if (tracks.length > 0) videoTrack = tracks[0];
  } catch (err) {
    alert("ã‚«ãƒ¡ãƒ©ã®èµ·å‹•ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒ–ãƒ©ã‚¦ã‚¶ã®ã‚«ãƒ¡ãƒ©åˆ©ç”¨ã‚’è¨±å¯ã—ã¦ãã ã•ã„ã€‚\n" + err);
    return;
  }

  video.addEventListener("loadeddata", () => {
    setupCanvas();
    requestAnimationFrame(draw);
  });
}

function setupCanvas() {
  canvas = document.getElementById("canvas");
  ctx = canvas.getContext("2d");
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  canvas.addEventListener("wheel", e => {
    e.preventDefault();
    scale += e.deltaY * -0.001;
    updateFValue();
  }, { passive: false });

  canvas.addEventListener("touchstart", e => { if (e.touches.length === 2) lastPinchDist = dist(e.touches[0], e.touches[1]); });
  canvas.addEventListener("touchmove", e => {
    e.preventDefault();
    if (e.touches.length === 2) {
      const currentDist = dist(e.touches[0], e.touches[1]);
      scale += (currentDist - lastPinchDist) * 0.005;
      lastPinchDist = currentDist;
      updateFValue();
    }
  }, { passive: false });
}

function updateFValue() {
  scale = Math.max(0.25, Math.min(scale, 4.0));
  fValue = 16.0 / scale / 4.0;
  fvalText.innerText = `Få€¤: ${fValue.toFixed(1)}`;
}

function dist(p1, p2) { return Math.sqrt(Math.pow(p1.clientX - p2.clientX, 2) + Math.pow(p1.clientY - p2.clientY, 2)); }

let lastBpmTime = 0;
function draw() {
  const videoRatio = video.videoWidth / video.videoHeight;
  const canvasRatio = canvas.width / canvas.height;
  let drawWidth, drawHeight, startX, startY;
  if (videoRatio > canvasRatio) {
    drawHeight = canvas.height; drawWidth = drawHeight * videoRatio;
    startX = (canvas.width - drawWidth) / 2; startY = 0;
  } else {
    drawWidth = canvas.width; drawHeight = drawWidth / videoRatio;
    startY = (canvas.height - drawHeight) / 2; startX = 0;
  }
  ctx.drawImage(video, startX, startY, drawWidth, drawHeight);

  if (isFlashOn) {
    const frame = ctx.getImageData(canvas.width / 2 - 10, canvas.height / 2 - 10, 20, 20);
    let sumRed = 0;
    for (let i = 0; i < frame.data.length; i += 4) sumRed += frame.data[i];
    const avgRed = sumRed / (frame.data.length / 4);
    
    if (!isNaN(avgRed)) {
      redHistory.push({ value: avgRed, time: Date.now() });
    }
    if (redHistory.length > 200) redHistory.shift();
    
    const now = Date.now();
    if (redHistory.length > 100 && now - lastBpmTime > 1000) {
      bpmText.innerText = `BPM: è¨ˆæ¸¬ä¸­...`;
      const newBpm = calculateBPM_Autocorrelation(redHistory);
      if (newBpm > 40 && newBpm < 200) {
        bpm = newBpm;
        bpmText.innerText = `BPM: ${bpm}`;
      }
      lastBpmTime = now;
    }
  }

  ctx.fillStyle = "rgba(0,0,0,0.8)";
  ctx.beginPath();
  const outerRadius = Math.max(canvas.width, canvas.height);
  ctx.arc(canvas.width / 2, canvas.height / 2, outerRadius, 0, 2 * Math.PI);
  const innerRadius = 50 * scale;
  ctx.arc(canvas.width / 2, canvas.height / 2, innerRadius, 0, 2 * Math.PI, true);
  ctx.fill();

  requestAnimationFrame(draw);
}

// --- æ–°ã—ã„BPMè¨ˆç®—ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ  (è‡ªå·±ç›¸é–¢æ³•) ---
function calculateBPM_Autocorrelation(history) {
    const signal = history.map(p => p.value);
    const times = history.map(p => p.time);

    // 1. ä¿¡å·ã®å¹³å‡å€¤ã‚’0ã«ã™ã‚‹ (Detrend)
    const mean = signal.reduce((a, b) => a + b, 0) / signal.length;
    const detrendedSignal = signal.map(v => v - mean);

    // 2. ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ãƒ¬ãƒ¼ãƒˆã‚’è¨ˆç®—
    const duration = (times[times.length - 1] - times[0]) / 1000; // in seconds
    const samplingRate = (times.length - 1) / duration;

    // 3. è‡ªå·±ç›¸é–¢ã‚’è¨ˆç®—ã™ã‚‹ãƒ©ã‚°ã®ç¯„å›²ã‚’æ±ºã‚ã‚‹ (40BPMã‹ã‚‰200BPM)
    const minLag = Math.floor(samplingRate * (60 / 200)); 
    const maxLag = Math.ceil(samplingRate * (60 / 40));
    
    let bestLag = 0;
    let maxCorr = 0;

    // 4. è‡ªå·±ç›¸é–¢ã‚’è¨ˆç®—
    for (let lag = minLag; lag <= maxLag; lag++) {
        let corr = 0;
        for (let i = 0; i < detrendedSignal.length - lag; i++) {
            corr += detrendedSignal[i] * detrendedSignal[i + lag];
        }
        if (corr > maxCorr) {
            maxCorr = corr;
            bestLag = lag;
        }
    }

    if (bestLag === 0) return 0;

    // 5. æœ€ã‚‚ç›¸é–¢ã®é«˜ã‹ã£ãŸãƒ©ã‚°ã‹ã‚‰BPMã‚’è¨ˆç®—
    const period = bestLag / samplingRate; // in seconds
    return Math.round(60 / period);
}


flashBtn.addEventListener("click", () => {
  if (!videoTrack) return;
  isFlashOn = !isFlashOn;
  redHistory = []; // ãƒªã‚»ãƒƒãƒˆ
  bpmText.innerText = 'BPM: ---';
  videoTrack.applyConstraints({ advanced: [{ torch: isFlashOn }] });
  flashBtn.style.background = isFlashOn ? "#ffdd59" : "rgba(255, 255, 255, 0.3)";
  if (isFlashOn) instructions.style.display = 'none';
});

captureBtn.addEventListener("click", () => {
  const tempCanvas = document.createElement('canvas');
  const tempCtx = tempCanvas.getContext('2d');
  tempCanvas.width = canvas.width; tempCanvas.height = canvas.height;
  tempCtx.drawImage(canvas, 0, 0);
  const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
  const data = imageData.data;
  
  const currentBpm = (bpm > 40 && bpm < 200) ? bpm : 60;
  const factor = 2.0 / (fValue * (currentBpm / 60));

  for (let i = 0; i < data.length; i += 4) {
    data[i] = Math.min(255, data[i] * factor);
    data[i+1] = Math.min(255, data[i+1] * factor);
    data[i+2] = Math.min(255, data[i+2] * factor);
  }
  tempCtx.putImageData(imageData, 0, 0);

  const link = document.createElement('a');
  link.href = tempCanvas.toDataURL("image/jpeg", 0.9);
  link.download = `heart_camera_f${fValue.toFixed(1)}_bpm${currentBpm}.jpg`;
  link.click();
});

initCamera();
</script>
</body>
</html>
